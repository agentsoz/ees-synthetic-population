---
title: "A synthetic population for Surf Coast Shire"
author: Dhirendra Singh, Joel Robertson
output:
  html_document:
    keep_md: yes
#  md_document:
#    variant: markdown_github
---


## Contents 
<!-- NOTE: table of contents should to be manually updated when headings are added/updated -->
* [Latest working model](#latest-working-model)
    * [Population subgroups](#population-subgroups)
    * [Activity types](#activity-types)
    * [Model assumptions](#model-assumptions)
    * [Model description](#model-description)
    * [Model inputs](#model-inputs)
    * [Model outputs](#model-outputs)
    * [Daily plans generation algorithm](#daily-plans-generation-algorithm)
    * [Quality of the output plans](#quality-of-the-output-plans)
    * [Activity distributions in original SCS plans file](#activity-distributions-in-original-scs-plans-file)


* [Background discussion](#background-discussion)
    * [V0.3](#v0.3)
    * [V0.2](#v0.2)
    * [V0.1](#v0.1)
    * [V0.0](#v0.0)

---

# Background discussion

## V0.3


```{r message=FALSE, warning=FALSE, include=FALSE}
suppressMessages(require(reshape2))
require(ggplot2)

# Function to plot a matrix of activities, where
# cols represent activities (such that each col adds up to 100%)
# rows represent time of day (hours)
# Assumes 12 entries per row (for each 2 hour interval)
plotActivities <- function (plotTitle, x_lab, y_lab, activities, limitY=TRUE) {
df<-melt(activities)
colnames(df)<-c("Activity", "Hour", "Proportion")
df$Hour<-(df$Hour-0.5)*2 # get the time of day correct
gg<-ggplot(df, aes(Hour, Proportion, fill=Activity)) +
  geom_col() +
  ggtitle(plotTitle) + 
  scale_x_continuous(name=y_lab, limits=c(0,24), breaks=seq(2,24,2)) +
  theme(legend.position = "bottom", legend.title=element_text(size=8), legend.text=element_text(size=7), legend.key.size = unit(0.6, "line")) 
if(limitY) {
  gg<-gg +   scale_y_continuous(name=x_lab, limits=c(0,100), breaks=seq(0,100,10))
}
gg
}

```


The idea described in `v0.2` below works ok algorithmically, but is not user friendly, because specifying the start time distributions manully is not intuitive and is likely to be error-prone. Certainly, the kinds of distributions drawn in `v0.1`, that capture what people are doing at different times of the day, make more sense for users. 

One option is to get users to specify the input in `v0.1`-like along with typical durations of activities, and then derive from those, the distributions required by the algorithm, i.e., `v0.2`-like. Here is an attempt at that.

Say we start with the following input distribution in the `v0.1` style:

```{r echo=FALSE, fig.width=5, fig.height=3}

### Resident

#hour   = c( 2,  4,  6,  8, 10, 12, 14, 16, 18, 20, 22, 24)
r_home  = c(90, 90, 85, 75, 30, 20, 15, 10, 25, 50, 80, 85)
r_work  = c( 5,  5, 10, 15, 50, 60, 60, 50, 40, 30, 10, 10)
r_beach = c( 0,  0,  0,  0,  5,  5, 10, 15,  5,  0,  0,  0)
r_shops = c( 0,  0,  0,  0, 10, 10, 10, 20, 25, 10,  5,  0)
r_other = 100 - (r_home + r_work + r_beach + r_shops)
r_activities = rbind(home=r_home, work=r_work, beach=r_beach, shops=r_shops, other=r_other)
n_activities = 100 * (r_activities / colSums(r_activities))
show(n_activities)
plotActivities("Resident", "Percentage", "Time of day", n_activities)
input<-plotActivities("Resident Input", "Percentage", "Time of day", n_activities)
```

As well as the following typical durations:
```{r echo=FALSE, fig.width=5, fig.height=3}

DURATIONS<-c(2,8,2,2,2)
durations<-matrix(DURATIONS, nrow=1, dimnames=list(c("hours"), c("home","work","beach","shops","other")))
show(durations)

#Added by Joel (to keep doc compatible)
durations<-DURATIONS
names(durations)<-c("home","work","beach","shops","other")
```

Now, let's just work with the `work` activity which has a typical duration ``r durations[,"work"]`` and looks like:
```{r echo=FALSE, fig.width=5, fig.height=3}
n_work<-matrix(n_activities["work",], nrow=1, ncol=length(n_activities["work",]), dimnames=list("work"))
show(n_work)
plotActivities("Residents at work (user input)", "Percentage", "Time of day", n_work)

```

```{r echo=FALSE, fig.width=5, fig.height=3}

derive_start_time <- function (n_activity,durations) {
  activity_name<-rownames(n_activity)[1]
  s_activity=matrix(0, nrow = dim(n_activity)[1], ncol = dim(n_activity)[2], dimnames=dimnames(n_activity)) # matrix to store start times
  t_work<-n_activity # temp copy of work matrix
  #print("t_work"); print(t_work)
  typical_duration<-durations[activity_name]
  block_size<-24/length(n_activity[activity_name,])
  for(h in 1:length(n_activity[activity_name,])) {
    h_work<-t_work[activity_name,h] # find out how many started work this hour
    #cat("h_work", h_work, "\n")
    s_activity[activity_name,h]<-h_work # save the start times for this hour
    #print("s_activity"); print(s_activity)
    block<-typical_duration/block_size # towards future bins to impact 
    block<-min(length(n_activity[activity_name,])-h+1, block) # towards future bins to impact
    bins<-h:(h+block-1) # ids of bins impacted
    #cat("bins impacted:", bins, "\n")
    t_work[activity_name, bins]<-t_work[activity_name, bins]-h_work # remove those who started work this hour
    t_work[t_work<0]<-0 # don't go below zero
    #print("t_work"); print(t_work)
  }
  return(s_activity)
}
```

The idea would be to cycle through the time bins for the day, and for each bin, save the number of persons starting the activity, and then remove those persons from the future bins corresponding to the typical duration of the activity. We then repeat the process for the next time bin. Here is what this looks like for the `work` activity:

```{r echo=FALSE, fig.width=5, fig.height=3}
n_work<-matrix(n_activities["work",], nrow=1, ncol=length(n_activities["work",]), dimnames=list("work"))
s_work<-derive_start_time(n_work,durations)
plotActivities("Residents starting work (derived)", "Percentage", "Time of day", s_work)
show(s_work)
```

Here is the same algorithm now applied to all the activities:

```{r echo=FALSE, fig.width=5, fig.height=3}
s_times<-matrix(0, nrow=nrow(n_activities), ncol=ncol(n_activities), dimnames=dimnames(n_activities))
for(activity in rownames(n_activities)) {
  n_activity<-matrix(n_activities[activity,], nrow=1, ncol=length(n_activities[activity,]), dimnames=list(activity))
  s_activity<-derive_start_time(n_activity,durations)
  s_times[activity,]<-s_activity
}
plotActivities("Residents starting activities (derived)", "Percentage", "Time of day", s_times)
show(s_times)
```


## V0.2

Outputs of agent-based simulation models are inherently very sensitive to the input population. For the GOR DSS, defining where the population is, what it is doing, and what it will do in response to an emergency will strongly influence the outputs. 

This is a proposal for *how the population will be specified by users*. The intent is to:

* make all inputs and assumptions about the underlying population explicit so that they can be more easily critiqued, debated, and agreed upon;
* allow differences between populations of different scenarios to be easily understood and described;
* allow users to generate populations for different scenarios easily; and
* formalise the method of producing such populations, so that they can be accurately reproduced.

In particular, what is proposed is a process for the construction of the input population with respect to the *expected spread of activites in the day* for different situations. The *output of the process is a CSV file*, similar to what is currently used as input to the DSS, that describes the daily activity-plan for every individual in the population.

We will make the following assumptions with respect to the activities of the population:

1. The choice of activities will be limited to the following fixed set:

Activity | Description
---------- | -------------------------------------------------------------------
**`home`** | *performed twice a day (morning, night)* at the home location of a person; these locations could either be random locations in the region, or random selections from known street addresses in the region (data available from LandVic); <mark>other suggestions welcome</mark>;
**`work`** | *performed once a day* at locations designated as work areas in the region (<mark>supplied by Surf Coast Shire Council</mark>); persons will be assigned arbitrary work location coordinates in these areas; the proportion of the resident population that forms the working cohort will be based on census data for the region (`ABS 2016: SCS had 90.6% employed of which 66% drive to work`); 
**`shop`** | *performed potentially once a day* at locations that represent retail and grocery shops as well as dining places; <mark>supplied by Surf Coast Shire Council</mark> 
**`beach`** | *performed potentially once a day* at areas designated as beach destinations along the coast (<mark>supplied by Surf Coast Shire Council</mark>); the population will have equal preference for all beaches; 
**`other`** | *performed potentially several times a day* at arbitrary locations other than those above (not including commuting); will be used as needed to make daily plans coherent.

1. Each population subgroup (i.e, `resident`, `regular visitor`, `tourist`) will differ in how they perform the above activities in the following ways:
    1. The proportions in which subgroups perform different activities will be different; for instance tourists might be more likely to go to the beach than residents; another example is that all residents will perform the home activity while none of the tourists will.
    1. The times at which subgroups perform activities will be different: for instance, tourists might be more likely to visit the beach around noon, whereas residents might be more inclined to go to the beach in the mornings and evenings to avoid the rush.
    1. The durations for which each subgroup performs activites will be different: for instance, tourists might spend more time at the beach than residents.

1. Overall, individuals in the full population will differ in the makeup of their daily activity plans with respect to which activities they perform, when, for how long, and in which order.

1. Each activity will be fully described by (1) a distribution specifying the expected start times in the day for the activity and (2) the *typical duration* of the activity (more on this below); these will differ for different situations such as between weekdays and weekends, and also for subgroups, such as between residents and tourists. Each scenario, such as "typical weekday" , will therefore be fully specified by three distributons (one per subgroup) and three activity durations. Each new scenario, such as "weekend", "40 degree day" will require three new distributions (and activity durations) each, so is not expected to be too onerous for users.

  1. The `typical duration` of an activity is the time a person will spend performing that activity under normal conditions, for instance 8hrs for `work`. The actual duration might get squeezed or stretched depending on how things play out during the simulation, such as due to traffic congestion. Details of the precise algorithm for this can be found in the MATSim user guide. 
  
  1. Currently in the model *persons* are synonomous with *vehicles*. In other words, all vehicles accommodate a single person (the driver) and drivers are assumed to be co-located with their vehicles. For SCS, it *might be important to model persons walking to activities from their parked vehicles and back at the end of the activity*. This might be important for the `beach` activity in particular, where the time spent in walking from/to the parked vehicle might be significant; <mark>Discuss with working group</mark>.

The following graphs show what the activity start time distributions and durations might look like for a "typical weekday":

```{r echo=FALSE, fig.width=5, fig.height=3}

### Resident

durations<-data.frame(activity=c("home","work","beach","shops","other"), typical_duration=c(12,8,2,1,1))
#hour   = c(  2,   4,   6,   8,  10,  12,  14,  16,  18,  20,  22,  24)
r_home  = c(100,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0)
r_work  = c(  0,   0,  30,  70,   0,   0,   0,   0,   0,   0,   0,   0)
r_beach = c(  0,   0,   5,  10,   0,   0,   0,   0,  10,   5,   0,   0)
r_shops = c(  0,   0,   0,   5,   5,   5,   5,  10,  20,  20,   5,   0)
r_other = c(  0,   5,  10,  10,   5,  15,  10,  10,  10,  10,   5,   0)
r_activities = rbind(home=r_home, work=r_work, beach=r_beach, shops=r_shops, other=r_other)
n_activities = r_activities #100 * (r_activities / colSums(r_activities))
plotActivities("Resident: activity start times", "Percentage", "Time of day", n_activities)
print("Activity start times (24hrs split over columns)");show(n_activities)
cat("Row sums (can exceed 100 if performed multiple times in the day):", rowSums(n_activities))
cat("Col sums (should not exceed 100):", colSums(n_activities))
show(durations)


### Regular Visitor


### Tourist


```


## V0.1

The plots below show what the distribution of activities might look like for the identified groups *on a typical weekday*.  

```{r echo=FALSE, fig.width=5, fig.height=3}

### Resident

#hour   = c(  2,   4,   6,   8,  10,  12,  14,  16,  18,  20,  22,  24)
r_home  = c(900, 900, 850, 750, 300, 200, 150, 100, 200, 450, 700, 850)
r_work  = c( 50,  50, 100, 150, 500, 600, 600, 500, 500, 400, 200, 100)
r_beach = c(  0,   0,   0,   0,  50, 50,  100, 150,  50,   0,   0,   0)
r_shops = c(  0,   0,   0,   0, 100, 100, 100, 200, 200, 100,  50,   0)
r_other = 1000 - (r_home + r_work + r_beach + r_shops)
r_activities = rbind(home=r_home, work=r_work, beach=r_beach, shops=r_shops, other=r_other)
n_activities = 100 * (r_activities / colSums(r_activities))
show(n_activities)
plotActivities("Resident", "Percentage", "Time of day", n_activities)


### Regular Visitor

#hour   = c(  2,   4,   6,   8,   10,  12,  14,  16,  18,  20,  22,  24)
v_home  = c(900, 950, 950, 850, 800, 650, 300, 250, 300, 400, 600, 700)
v_work  = c(  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0)
v_beach = c(  0,   0,   0,  50, 100, 100, 300, 400, 300, 100,  50,   0)
v_shops = c(  0,   0,   0,   0,  50, 100, 350, 200, 150, 400, 200,   0)
v_other = 1000 - (v_home + v_work + v_beach + v_shops)
v_activities = rbind(home=v_home, work=v_work, beach=v_beach, shops=v_shops, other=v_other)
n_activities = 100 * (v_activities / colSums(v_activities))
show(n_activities)
plotActivities("Regular Visitor", "Percentage", "Time of day", n_activities)

### Tourist

#hour   = c(  2,   4,   6,   8,   10,  12,  14,  16,  18,  20,  22,  24)
t_home  = c(  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0)
t_work  = c(  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0)
t_beach = c(  0,   0,   0,  100, 200, 600, 700, 600, 300, 100,  50,   0)
t_shops = c(  0,   0,   0,  100, 200, 300, 200, 200, 600, 500, 200,   0)
t_other = 1000 - (t_home + t_work + t_beach + t_shops)
t_activities = rbind(home=t_home, work=t_work, beach=t_beach, shops=t_shops, other=t_other)
n_activities = 100 * (t_activities / colSums(t_activities))
show(n_activities)
plotActivities("Tourist", "Percentage", "Time of day", n_activities)

```


## V0.0

[Surf Coast Shire](https://www.openstreetmap.org/relation/3290432) is unique in its population makeup on a given summer day, due to the significant high number of tourists in and around the townships that line the [Great Ocean Road](https://www.openstreetmap.org/relation/6592912). For instance, accounts from emergency services personnel suggest that the population of Angleasea can be as high as `15000` persons on a summer day, when the [resident population of Anglesea according to the 2016 census is around `2600`](http://www.censusdata.abs.gov.au/census_services/getproduct/census/2016/quickstat/SSC20045).  In looking to construct a synthetic population for Surf Coast Shire for the purposes of evacuation modelling then, it is importnat that the significantly high volume of traffic from tourism related activities in the area is accounted for. Further, the behaviour of tourists in case of an emergency is likely to differ from local residents, at least as far as knowledge of local roads is concerned.

One way to to approach the problem is to construct the population in *layers* of identified groups of people, that are then superimposed to create a final population on a given day. This gives finer control over modelled scenarios, such as to capture days with "packed" beaches, special events like the Falls Festival, and/or high through-traffic. 

### Evacuee types

Initial discussions with stakeholders (at Anglesea CFA, 16/04/18) identified the following three groups that conceptually make up the population:

* **Residents** : as captured by the [ABS census data](http://www.censusdata.abs.gov.au/census_services/getproduct/census/2016/quickstat/LGA26490); several methods exist for creating a synthetic population for this cohort, and one that could be readily applied here is the [algorithm from Wicramasinghe et al.](https://github.com/agentsoz/synthetic-population) from RMIT University. 
* **Regular visitors** : people that regularly visit the region during the summer months, camping or in *holiday homes*, and have a working knowledge of local roads and destinations; some information on this cohort could be derived from [VISTA data](https://transport.vic.gov.au/data-and-research/vista/). (<mark>Any other dataset that might give stats on this group?</mark>)
* **Tourists** : people that visit the region for the day or on a short-stay visit, and generally do not know the area well; some information on this cohort could be derived from [VISTA data](https://transport.vic.gov.au/data-and-research/vista/). (<mark>Any other dataset that might give stats on this group?</mark>)

These would likely be entered into DSS in the following format:

Type | Total numbers
----- | -----
Resident | 2500 (from ABS)
Regular Visitor | 2000
Tourist | 7000


### Evacuee response to messaging

The following table shows a suggested distribution of responses to various messages, for different types of persons (**each row must add up to 100%**). <mark>For discussion with Surf Coast Shire.</mark>

Person type | Evacuate on `Advice` | Evacuate on `Watch & Act` | Evacuate on `Evacuate Now` | Will not evacuate | Justification 
--------------|---------|---------|---------|---------|--------------------------------------------
Resident | 5% | 15% | 50% | 30% | Least likely to react to initial warnings; most likely to stay back 
Regular Visitor | 10% | 20% | 60% | 10% | More likely to react to warnings; less likely to stay back 
Tourist | 15% | 25% | 60% | 0% | Most likely to react early; least likely to stay back 

### Whereabouts of the population during the day

The current approach for building an understanding of the activities and whereabouts of the population at the time of the first warning is based on combining various sources of information to produce a trip-based activity plan for each person (see [example Surf Coast Shire trips](../from-scsc-201804/analysis-data-from-scsc-201804.html)). The trips can then be played out in MATSim, as a preparatory step, and *snapshots* of the population taken at desired times during the simulated day. These time-of-day based snapshots can then be used as inputs for evacuation scenarios as required.  
The key drawback of this approach is that the preparatory process requires manual manipulation (currently restricted to SCS personnel to produce the trips CSV file) which can be time consuming. This inherently restricts the amount of variation that can be built into the initial population, since each variation requires a separate application of the above process. For instance, it would be difficult to easily construct sets of initial populations that vary only in terms of size and makeup with respect to the identified evacuee groups.

The suggested approach would be to instead specify the initial population and its time-of-day based activities in terms of distributions, that are more amenable to easy manipulation between scenarios. This would remove the manual preprocessing step altogether, since the starting population for any new scenario would be fully described by and built from these distributions alone. For instace, the activity-based behaviours of the population could likely be simplified to being `at home`, `at work`, `at shops`, `at beach`, or `at other location`. These distributions would "look" similar for all types of persons, however the proportion of each type performing those activities would vary. 

Below is an example showing what two such distribution might look like:

```{r echo=FALSE, fig.width=8, fig.height=3}
library(ggplot2)

x<-seq(from=0, to=24,length.out=1000)
y<-dnorm(x, mean=10, sd=1)

y2<-dnorm(x, mean=15, sd=1.5)

y<-0.2*y+0.8*y2
a<-rep("At Beach", length(x))
df1<-data.frame(Hour=x,Proportion=y, Activity=a)

y<-dnorm(x, mean=11, sd=2)

y2<-dnorm(x, mean=18, sd=1.5)

y<-0.5*y+0.5*y2

a<-rep("At Shops", length(x))
df2<-data.frame(Hour=x,Proportion=y, Activity=a)

df<-rbind(df1,df2)
ggplot(df,aes(x=Hour,y=Proportion, color=Activity)) +labs(y="Density", x="Hour of day") +geom_line()+scale_x_continuous( limits=c(0,24), breaks=seq(2,24,2))
```

Proportion of the population of each type, likely to perform a given activity during the day (will be applied to the time-of-day distributions above):

Activity | Resident | Regular Visitor | Tourist
----- | ----- | ----- | -----
`At Home` | - | - | -
`At Work` | - | - | - 
`At beach` | 0.3 | 0.7 | 0.9 
`At Shops` | 0.5 | 0.7 | 0.9 
`At Other Location` | - | - | - 

Each activity will in turn be associated with a location, a set of locations, or areas (polygons).

The above information could then be used to automatically construct a "daily plan" for a given person. It may include several of the above activities, based on values specified in the ablve table. The information above is sufficient to determine the wherabouts of the full population at any time during the day.


# Latest working model


[Surf Coast Shire](https://www.openstreetmap.org/relation/3290432) is unique in its population makeup due to the high number of visitors to townships around the [Great Ocean Road](https://www.openstreetmap.org/relation/6592912). On a given summer day for instance, Angleasea that has a [resident population around `2600`](http://www.censusdata.abs.gov.au/census_services/getproduct/census/2016/quickstat/SSC20045) can have as many as `15000` persons in the township.  In looking to construct a synthetic population for Surf Coast Shire for the purposes of evacuation modelling, it is therefore important to consider the numbers as well as behaviours of the significant transient population in the region.


## Population subgroups

Within the model, we will account for the following groups of people (based on input from regional stakeholders):

* `resident` : as captured by the [ABS census data](http://www.censusdata.abs.gov.au/census_services/getproduct/census/2016/quickstat/LGA26490); several methods exist for creating a synthetic population for this cohort, and one that could be readily applied here is the [algorithm from Wicramasinghe et al.](https://github.com/agentsoz/synthetic-population) from RMIT University. 
* `regular visitor` : people that regularly visit the region during the summer months, camping or in *holiday homes*, and have a working knowledge of local roads and destinations; some information on this cohort could be derived from [VISTA data](https://transport.vic.gov.au/data-and-research/vista/). (<mark>Any other dataset that might give stats on this group?</mark>)
* `tourist` : people that visit the region for the day or on a short-stay visit, and generally do not know the area well; some information on this cohort could be derived from [VISTA data](https://transport.vic.gov.au/data-and-research/vista/). (<mark>Any other dataset that might give stats on this group?</mark>)

## Activity types

The [initial work done by Surf Cost Shire Council](https://github.com/agentsoz/bdi-abm-integration/blob/kaibranch/examples/bushfire/scenarios/surf-coast-shire/data/from-scsc-201804/analysis-data-from-scsc-201804.md#surf-coast-shire-trips-scscsvgz) looked at the following types of activites (counts): 
`Base`(144456)
`Beach`(5578)
`Business`(39399)
`Camp`(189)
`Caravan`(7986)
`EvacZone`(48370)
`Golf`(1508)
`Hotel`(2057)
`Kindergarten`(333)
`Primary`(1123)
`Secondary`(972)
`Shops`(36193)
`Tafe`(378)
`University`(370)

In the new model, the choice of activities is limited to the following fixed set (<mark>TODO: add `Education` category</mark>):

Activity | Description
---------- | -------------------------------------------------------------------
**`home`** | *performed twice a day (morning, night)* at the home location of a person (MATSim requirement); these locations could either be random locations in the region, or random selections from known street addresses in the region (data available from LandVic); <mark>other suggestions welcome</mark>;
**`work`** | *performed once a day* at locations designated as work areas in the region (<mark>supplied by Surf Coast Shire Council</mark>); persons will be assigned arbitrary work location coordinates in these areas; the proportion of the resident population that forms the working cohort will be based on census data for the region (`ABS 2016: SCS had 90.6% employed of which 66% drive to work`); 
**`shop`** | *performed potentially several times a day* at locations that represent retail and grocery shops as well as dining places; <mark>supplied by Surf Coast Shire Council</mark> 
**`beach`** | *performed potentially several times a day* at areas designated as beach destinations along the coast (<mark>supplied by Surf Coast Shire Council</mark>); the population will have equal preference for all beaches; 
**`other`** | *performed potentially several times a day* at arbitrary locations other than those above (not including commuting); will be used as needed to make daily plans coherent.

## Model assumptions

1. Each population subgroup (i.e, `resident`, `regular visitor`, `tourist`) will differ in how they perform the above activities in the following ways:
    1. The proportions in which subgroups perform different activities will be different; for instance tourists might be more likely to go to the beach than residents; another example is that all residents will perform the home activity while none of the tourists will.
    1. The times at which subgroups perform activities will be different: for instance, tourists might be more likely to visit the beach around noon, whereas residents might be more inclined to go to the beach in the mornings and evenings to avoid the rush.
    1. The durations for which each subgroup performs activites will be different: for instance, tourists might spend more time at the beach than residents.

1. Overall, individuals in the full population will differ in the makeup of their daily activity plans with respect to which activities they perform, when, for how long, and in which order.

  1. The `typical duration` of an activity is the time a person will spend performing that activity under normal conditions, for instance 8hrs for `work`. The actual duration might get squeezed or stretched depending on how things play out during the simulation, such as due to traffic congestion. Details of the precise algorithm for this can be found in the [MATSim user guide](http://ci.matsim.org:8080/job/MATSim-Book/ws/partOne-latest.pdf). 
  
  1. Currently in the model *persons are synonomous with vehicles*. In other words, all vehicles accommodate a single person (the driver) and drivers are assummed to be co-located with their vehicles. For SCS, it *might be important to model persons walking to activities from their parked vehicles and back at the end of the activity*. This might be important for the `beach` activity in particular, where the time spent in walking from/to the parked vehicle might be significant; <mark>Discuss with working group</mark>.

## Model description

The purpose of the model is to allow users to specify the makeup of the population for specific situations, such as "Typical summer weekday/weekend", ":"Falls Festival day with FFDI=100, and so on. The intent is to:

* make all inputs and assumptions about the underlying population explicit so that they can be more easily critiqued, debated, and agreed upon;
* allow differences between populations of different scenarios to be easily understood and described;
* allow users to generate populations for different scenarios easily and automatically; and
* formalise the method of producing such populations, so that they can be accurately reproduced.

## Model inputs

*For each situation, for each population subgroup, users specify three inputs*:

* The distribution of activites through the day;
* the typical durations of activities; and
* which activities are repeatable within the day.

For instance, on a "typical summer weekday", the input for the `resident` subgroup might look like:

```{r echo=FALSE, fig.width=5, fig.height=3}

### Resident

#hour   = c( 2,  4,  6,  8, 10, 12, 14, 16, 18, 20, 22, 24)
r_home  = c(90, 90, 85, 75, 30, 20, 15, 10, 25, 50, 80, 85)
r_work  = c( 5,  5, 10, 15, 50, 60, 60, 50, 40, 30, 10, 10)
r_beach = c( 0,  0,  0,  0,  5,  5, 10, 15,  5,  0,  0,  0)
r_shops = c( 0,  0,  0,  0, 10, 10, 10, 20, 25, 10,  5,  0)
r_other = 100 - (r_home + r_work + r_beach + r_shops)
r_activities = rbind(home=r_home, work=r_work, beach=r_beach, shops=r_shops, other=r_other)
n_activities = 100 * (r_activities / colSums(r_activities))
plotActivities("Resident", "Percentage", "Time of day", n_activities)
input<-plotActivities("Resident activities (Input)", "Percentage", "Time of day", n_activities)
show("Resident activities (above graph in numbers; rows add to 100%)"); show(n_activities)

DURATIONS<-c(2,8,2,2,2)
durations<-matrix(DURATIONS, nrow=1, dimnames=list(c("hours"), c("home","work","beach","shops","other")))
show("Typical duration of activities"); show(durations)

REPEATING<-c(1,0,1,1,1)
repeating<-matrix(REPEATING, nrow=1, dimnames=list(c("hours"), c("home","work","beach","shops","other")))
show("Repeatability of activities within the day");show(repeating)
```



## Model outputs

The *output of the process is a CSV file*, similar to what is currently used as input to the DSS, that describes the daily activity-plan for every individual in the population. An [example output CSV file is here](./plan.csv). The output can *easily be converted to a MATSim population plans XML file*.


## Daily plans generation algorithm


The algorithm takes as input the activities distributions and typical durations, and first derives the start times distribution for each activity. Here is what this looks like for the `resident` example:

```{r echo=FALSE, fig.width=5, fig.height=3}
plotActivities("Residents starting activities (derived)", "Percentage", "Time of day", s_times)
show(s_times)
```


Next, the plan algorithm takes this distribution and iteratively constructs a plan for each agent, taking into account the repeatability constraints for activities. For a given resident, the algorithm allocates an activity for each time block. It then iterates over the day and rules out those activities that are overlapped by the duration of a previous activity, as well as the unrepreatable activities that have already occured. Each plan would start and end at `home`, with any new activity set to start (or more precisely, the previous activity to end) at the midpoint of each bin.




```{r echo=FALSE, fig.width=5, fig.height=3}
prob_matrix<-function (n_activities,durations,repeating,type)
{

if (sum(colSums(n_activities)-100)!=0)
{
  print("ERROR: one or more columns in distribution table do not sum to 100%")
  break
}  
  
s_times<-matrix(0, nrow=nrow(n_activities), ncol=ncol(n_activities), dimnames=dimnames(n_activities))
for(activity in rownames(n_activities)) {
  n_activity<-matrix(n_activities[activity,], nrow=1, ncol=length(n_activities[activity,]), dimnames=list(activity))
  s_activity<-derive_start_time(n_activity,durations)
  s_times[activity,]<-s_activity
}
start<-s_times/100
shift<-matrix(colSums(start),nrow(n_activities),12,byrow=T)
saveshift<-shift
rept<-(repeating-1)*-1 #invert repeat vector
if(sum(rowSums(rept*start)>1))
{
  problem<-which(rowSums(rept*start)>1)
  print(paste0("ERROR: non-repeatable activity ",names(problem)," cannot be completed by ",rowSums(rept*start)[problem]*100,"% of the ",type," population. Try increasing duration time for activity, reducing overall distribution of activity, or making activity repeatable."))
  break
}

dur<-durations
#nonrepeat correction
for (i in 1:nrow(n_activities))
{
  if (rept[i]>0)
  {
    len=(rept*dur)[i]
    for (g in (1+len):12)
    {
    
      subj=shift[i,g]-sum(start[i,1:(g-len)])#sum(start[i,1:(g-len)])
    cont=(shift[i,g]-start[i,g])/(1-(start[i,g]/(subj)))
    shift[,g]=cont
    shift[i,g]=subj
    }
  }
    
}
prob=start/shift

# p_resident<-1-(1-p_resident)^(1/p) #(for timesteps!=2 trying to spread prob according to timestep- a bit dodgy)
cum_prob<-apply(prob,2,cumsum) #cumulative sums for each column
return(cum_prob)
}
```


```{r echo=FALSE, fig.width=5, fig.height=3}
##Returns a list of plans for the agent type with start times allocated to each activity.
plan_times<-function (number_of_agents,probability_matrix,durations,repeating)
{  
dur<-as.vector(durations)/2
rept<-(repeating-1)*-1
N<-number_of_agents
n<-ncol(probability_matrix)
PLANS<-list()
for (h in 1:N)
  
{

roll<-runif(n) #roll for each timestep 

#activity is allocated at each timestep
agent<-apply(probability_matrix,1,function(x){roll<x}) 
agent<-apply(agent,1,cumsum) 
agent[agent>1]=0

agent<-dur*agent #insert durations into matrix
z=rep(0,5) #blank vector
s=0  #block flag
r=z  #repeat flag

#cycle through to see which potential activities actually occur
for (j in 1:n)
{
 if(s>0)
   {
      agent[,j]=agent[,j-1] #block timesteps following activity.
      s=s-1
 }
  else #at this point, the timestep changes to it's activity
    {
      if (sum(r*agent[,j])>0) #check if unrepeatable activity has already occurred
    {
      pass=r
        while(sum(pass*agent[,j])>0)
          {
          
      agent[,j]<-dur*(abs(cumsum(probability_matrix[,j]>runif(1))-1)<1)#reroll
      pass=agent[,j]*rept #check repeat again

      }

      }

      s=sum(agent[,j])-1 # if a new activity is activated, set its       block duration
      r=r+agent[,j]*rept #check repeat
      
        
       } 
}
agent=agent/dur
names<-row.names(agent)
re=agent
for (i in 2:12)
{
  re[,i]=agent[,i]-agent[,i-1]
}
re[re<1]=0
re=colSums(re*(row(re)))
activity=names[re]
re=as.matrix(re)
start_time=re*(2*row(re)-1)*100/re
start_time=start_time[complete.cases(start_time*0),,drop=FALSE]
start_time=as.integer(start_time)
start_time=start_time+c(-99,sample(c(-99:-41,0:59),length(start_time)-1))
person=rep(h,length(start_time))
plan=data.frame(cbind(person,activity,start_time))
plan[]<-lapply(plan,as.character)

##Ensure resident starts and ends at home
header<-plan[1,]
header[2]<-"home"
header[3]<-"0000"
if (plan[1,2]=="home")
{
 plan[1,3]=0
} else
{
  plan<-rbind(header,plan)
}

footer<-header
footer[3]<-"2359"
if (tail(plan,1)[2]!="home")
{
  plan<-rbind(plan,footer)
}

##add zero characters if necessary 
for (yy in 1:nrow(plan))
{
  lenn<-4-nchar(plan[yy,3])
  if(lenn>0)
    
  {
    for (yyy in 1:lenn)
    {
      plan[yy,3]<-paste0("0",plan[yy,3])
    }
  }
  plan[yy,3]<-paste0(substr(plan[yy,3],0,nchar(plan[yy,3])-2),":",substr(plan[yy,3],nchar(plan[yy,3])-1,nchar(plan[yy,3])),":00")
}
PLANS[[h]]<-plan
}
return(PLANS)
}
```

```{r echo=FALSE, fig.width=5, fig.height=3}
location_map<-function (locations_csv_file,location_type_title,xcoord_title,ycoord_title,location_names)
{ 
  ##Get Location Coordinates
locs<-read.csv(locations_csv_file)
locations<-locs[,c(location_type_title,xcoord_title,ycoord_title)]
LOCATIONS<-list()
for (activity in names(location_names))
{
  LOCATIONS[[activity]]<-locations[locations[[location_type_title]] %in% location_names[[activity]],]
  
}  

return(LOCATIONS)
}
```

```{r echo=FALSE, fig.width=5, fig.height=3}
plan_locations<-function (plan_times,activity_locations)
{
PLANS<-plan_times  
for (h in 1:length(PLANS))
{
plan<-PLANS[[h]]  

#choose home location
home<-activity_locations$home[sample(nrow(activity_locations$home),1),]

##OUTDATED- find random location in region for home##
# #find a random point in region for home
# base_boundary<-5720833.61
# top_boundary<-5768396.15
# left_boundary<-730836.84
# right_boundary<-800760.82
# 
# 
# #rudimentary polygon coverage of region
# home[3]<-sample(base_boundary:top_boundary,1)
# if(home[3]<5726653.13){home[2]<-sample(left_boundary:752986.88,1)}
# else if(home[3]<5735039.79){home[2]<-sample(left_boundary:758086.83,1)}
# else if(home[3]<5739007.31){home[2]<-sample(left_boundary:762321.79,1)}
# else if(home[3]<5742042.88){home[2]<-sample(left_boundary:771685.48,1)}
# else if(home[3]<5745592.95){home[2]<-sample(left_boundary:777087.77,1)}
# else if(home[3]<5750622.83){home[2]<-sample(left_boundary:783519.07,1)}
# else if(home[3]<5754527.65){home[2]<-sample(left_boundary:789417.10,1)}
# else if(home[3]<5757917.72){home[2]<-sample(left_boundary:794088.29,1)}
# else {home[2]<-sample(left_boundary:right_boundary,1)}

plan$xcoord=matrix(home[2],nrow(plan))
plan$ycoord=matrix(home[3],nrow(plan))
plan$xcoord=unlist(plan$xcoord)
plan$ycoord=unlist(plan$ycoord)

##find appropriate location for other activities (using probability based on 1/distance^2)
for (i in 1:nrow(plan))
{
  activity<-plan[i,2]
  if (activity!="home")
  {
  #find Euclidean distance between home and potential destinations  
  distances=activity_locations[[activity]][,2:3]-unlist(matrix(home[2:3],nrow(activity_locations[[activity]]),2,byrow = T))
  distances=distances^2
  distances=sqrt(rowSums(distances))
  
  #choose based on inverse square law ##ASSUMPTION
  place=sample(distances,1,prob = 1/(distances^2))
  place=activity_locations[[activity]][which(rownames(activity_locations[[activity]])==names(place)),]
  plan[i,4:5]=place[2:3]
  }
}
PLANS[[h]]<-plan
}
return(PLANS)
}
```


```{r echo=FALSE, fig.width=5, fig.height=3}
type_plan<-function (n_activities,number_of_agents,durations,repeating,location_csv_file,location_names,type)
{
probability_matrix<-prob_matrix(n_activities,durations,repeating,type)
plan_times_type<-plan_times(number_of_agents,probability_matrix,durations,repeating)

## If locations csv file is altered, the names of the relevant columns might need to be changed here
activity_locations<-location_map(locations_csv_file,location_type_title = "LandUse",xcoord_title = "xcoord",ycoord_title = "ycoord",location_names=location_names)

PLANS<-plan_locations(plan_times = plan_times_type,activity_locations =activity_locations)  
  
return(PLANS)
}
```

```{r echo=FALSE, fig.width=5, fig.height=3}
write_xml<-function (PLANS)
{
  plans<-file("plans.xml", open = "w+")
  head<-'<?xml version="1.0" ?>
<!DOCTYPE plans SYSTEM "http://www.matsim.org/files/dtd/plans_v4.dtd">
<plans>
<!-- ====================================================================== -->'
  cat(head,file = plans, append=FALSE, sep = "\n")
  
  ct=0
  for (Type in names(PLANS))
  {
    for (i in 1:length(PLANS[[Type]]))
    {
      plan<-as.data.frame(PLANS[[Type]][i])
      person<-paste0('  <person id= "',ct,'" >\n    <plan selected="yes">\n      ')
      for (j in 1:nrow(plan))
        {
          if (j<nrow(plan))
        {
          person<-paste0(person,'<act type="',plan[j,2],'" x="',plan[j,4],'" y="',plan[j,5],'" end_time="',plan[j+1,3],'" />\n      <leg mode="car" />\n      ')
          
        }
        else
        {
        if (j==1)
          {
           person<-paste0(person,'<act type="',plan[j,2],'" x="',plan[j,4],'" y="',plan[j,5],'" end_time="06:00:00" />\n      <leg mode="car" />\n      ')
          }
         person<-paste0(person,'<act type="',plan[j,2],'" x="',plan[j,4],'" y="',plan[j,5],'" />\n    </plan>\n  </person>\n  ')
    
        }
        }
		cat(person, file = plans, append=FALSE, sep = "\n")
      ct=ct+1
    }
  }
 foot<-'<!-- ====================================================================== -->

</plans>'
 cat(foot, file = plans, append=FALSE, sep = "\n")
 close(plans) 
}
```

```{r echo=FALSE, fig.width=5, fig.height=3}

###Algorithm to generate a resident plan (based on ver 0.1)
#****(To navigate, search for the step by step options with '****' )
#################################################################
##INPUTS

#**** 1. Choose the number of each agent type:
NUMBER<-c(20,20,20,20,20)
names(NUMBER)<-c("Resident","PT Resident","Regular Visitor","Overnight Visitor","Day Visitor")

#**** 2. Set how each subpopulation will be distributed over the 12 2-hr time block:s
DISTRIBUTIONS<-list()

### Resident
#hour   = c( 2,  4,  6,  8, 10, 12, 14, 16, 18, 20, 22, 24)
r_home  = c(90, 90, 85, 75, 30, 20, 15, 10, 25, 50, 80, 85)
r_work  = c( 5,  5, 10, 15, 50, 60, 60, 50, 40, 30, 10, 10)
r_beach = c( 0,  0,  0,  0,  5,  5, 10, 15,  5,  0,  0,  0)
r_shops = c( 0,  0,  0,  0, 10, 10, 10, 20, 25, 10,  5,  0)
r_other = 100 - (r_home + r_work + r_beach + r_shops)
r_activities = rbind(home=r_home, work=r_work, beach=r_beach, shops=r_shops, other=r_other)
DISTRIBUTIONS[["Resident"]]= 100 * (r_activities / colSums(r_activities))

### Part-time Resident
#hour   = c( 2,  4,  6,  8, 10, 12, 14, 16, 18, 20, 22, 24)
p_home  = c(90, 90, 85, 75, 30, 20, 15, 10, 25, 50, 80, 85)
p_work  = c( 5,  5, 10, 15, 50, 60, 60, 50, 40, 30, 10, 10)
p_beach = c( 0,  0,  0,  0,  5,  5, 10, 15,  5,  0,  0,  0)
p_shops = c( 0,  0,  0,  0, 10, 10, 10, 20, 25, 10,  5,  0)
p_other = 100 - (p_home + p_work + p_beach + p_shops)
p_activities = rbind(home=p_home, work=p_work, beach=p_beach, shops=p_shops, other=p_other)
DISTRIBUTIONS[["PT Resident"]]= 100 * (p_activities / colSums(p_activities))

### Regular Visitor
#hour   = c( 2,  4,  6,  8, 10, 12, 14, 16, 18, 20, 22, 24)
v_home  = c(90, 95, 95, 85, 80, 65, 30, 25, 30, 40, 60, 70)
v_work  = c( 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0)
v_beach = c( 0,  0,  0, 50, 10, 10, 30, 40, 30, 10,  5,  0)
v_shops = c( 0,  0,  0,  0, 50, 10, 35, 20, 15, 40, 20,  0)
v_other = 100 - (v_home + v_work + v_beach + v_shops)
v_activities = rbind(home=v_home, work=v_work, beach=v_beach, shops=v_shops, other=v_other)
DISTRIBUTIONS[["Regular Visitor"]]= 100 * (v_activities / colSums(v_activities))


### Overnight Visitor
#hour   = c(  2,   4,   6,   8,  10,  12,  14,  16,  18,  20,  22,  24)
o_home  = c( 95,  95,  80,  50,  10,   0,   0,  10,  20,  40,  60, 100)
o_work  = c(  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0)
o_beach = c(  0,   0,  15,  10,  20,  60,  70,  50,  20,  10,   5,   0)
o_shops = c(  5,   0,   0,  10,  20,  30,  20,  20,  40,  40,  20,   0)
o_other = 100 - (o_home + o_work + o_beach + o_shops)
o_activities = rbind(home=o_home, work=o_work, beach=o_beach, shops=o_shops, other=o_other)
DISTRIBUTIONS[["Overnight Visitor"]]= 100 * (o_activities / colSums(o_activities))

### Day Visitor
#hour   = c(  2,   4,   6,   8,  10,  12,  14,  16,  18,  20,  22,  24)
d_home  = c(100, 100,  90,  20,  10,   0,   0,  10,  20,  40,  60, 100)
d_work  = c(  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0)
d_beach = c(  0,   0,   5,  10,  20,  40,  50,  40,  20,  10,   5,   0)
d_shops = c(  0,   0,   0,  10,  20,  30,  20,  20,  40,  40,  20,   0)
d_other = 100 - (d_home + d_work + d_beach + d_shops)
d_activities = rbind(home=d_home, work=d_work, beach=d_beach, shops=d_shops, other=d_other)
DISTRIBUTIONS[["Day Visitor"]]= 100 * (d_activities / colSums(d_activities))


#**** 3. Set the duration of each activity, for each type (MUST BE A MULTIPLE OF 2):                               
DURATIONS<-matrix(c(
                  #RESIDENT 
                  c(2,8,2,2,2),
                  #PT RESIDENT
                  c(2,8,2,2,2),
                  #REG. VISITOR
                  c(2,8,2,2,2),
                  #O'N VISITOR
                  c(8,8,2,2,2),
                  #DAY VISITOR  
                  c(2,8,4,2,2)),      nrow =5,byrow = T)
rownames(DURATIONS)<-c("Resident","PT Resident","Regular Visitor","Overnight Visitor","Day Visitor")
colnames(DURATIONS)<-rownames(DISTRIBUTIONS$Resident)
         
#**** 4. Set the repeating behaviour for each activity, for each type (MUST HAVE AT LEAST ONE REPEATING ACTIVITY PER TYPE):         
REPEATING<-matrix(c(
                  #RESIDENT 
                  c(1,0,1,1,1),
                  #PT RESIDENT
                  c(1,0,0,0,0),
                  #REG. VISITOR
                  c(1,0,1,1,1),
                  #O'N VISITOR
                  c(1,0,1,1,1),
                  #DAY VISITOR  
                  c(1,0,0,1,1)),      nrow =5,byrow = T)
rownames(REPEATING)<-c("Resident","PT Resident","Regular Visitor","Overnight Visitor","Day Visitor")
colnames(REPEATING)<-rownames(DISTRIBUTIONS$Resident)

#**** 5.Specify the path to locations csv file (exported from Locations shp file): 
locations_csv_file ="Locations.csv"

#**** 6. Map the csv locations to the activities specified for each type:
LOCATIONS<-list()

###Resident
r_location_names<-list()
r_location_names[["home"]]<-c("EvacZone")
r_location_names[["work"]]<-c("Business District","Caravan Park","Hotel","Golf Club")
r_location_names[["beach"]]<-c("Beach")
r_location_names[["shops"]]<-c("Shops")
r_location_names[["other"]]<-c("University","Secondary","Tafe","Kindergarten","Primary")
LOCATIONS[["Resident"]]<-r_location_names

###Part-time Resident
p_location_names<-list()
p_location_names[["home"]]<-c("EvacZone")
p_location_names[["work"]]<-c("Business District","Caravan Park","Hotel","Golf Club")
p_location_names[["beach"]]<-c("Beach")
p_location_names[["shops"]]<-c("Shops")
p_location_names[["other"]]<-c("University","Secondary","Tafe","Kindergarten","Primary")
LOCATIONS[["PT Resident"]]<-p_location_names

###Regular Visitor
v_location_names<-list()
v_location_names[["home"]]<-c("EvacZone")
v_location_names[["work"]]<-c("Business District","Caravan Park","Hotel","Golf Club")
v_location_names[["beach"]]<-c("Beach")
v_location_names[["shops"]]<-c("Shops")
v_location_names[["other"]]<-c("University","Secondary","Tafe","Kindergarten","Primary")
LOCATIONS[["Regular Visitor"]]<-v_location_names

###Overnight Visitor
o_location_names<-list()
o_location_names[["home"]]<-c("Caravan Park","Hotel","Golf Club","Camp")
o_location_names[["work"]]<-c("Business District","Caravan Park","Hotel","Golf Club")
o_location_names[["beach"]]<-c("Beach")
o_location_names[["shops"]]<-c("Shops")
o_location_names[["other"]]<-c("University","Secondary","Tafe","Kindergarten","Primary")
LOCATIONS[["Overnight Visitor"]]<-o_location_names

###Day Visitor
d_location_names<-list()
d_location_names[["home"]]<-c("Colac","Geelong")
d_location_names[["work"]]<-c("Business District","Caravan Park","Hotel","Golf Club")
d_location_names[["beach"]]<-c("Beach")
d_location_names[["shops"]]<-c("Shops")
d_location_names[["other"]]<-c("Camp","NSP")
LOCATIONS[["Day Visitor"]]<-d_location_names


######################################################################
#**** 7. Run code using (ctrl+alt+R) the first time (slow, but loads in functions), and then (ctrl+shift+enter) after that




#main
PLANS<-list()
for (Type in names(NUMBER))
{
PLANS[[Type]]<-type_plan(DISTRIBUTIONS[[Type]],NUMBER[Type],DURATIONS[Type,],REPEATING[Type,],location_csv_file,LOCATIONS[[Type]],Type)
}

#write xml (to working directory)
write_xml(PLANS)


```
<!-- COMMENTED OUT DUE TO DEPRECEATION -->
<!-- Here is an example plan for a resident, with durations, and where only `work` is non-repeatable. A cell with a `1` indicates a 2-hr block in the day (column) where the resident is performing an activity (row): -->

<!-- ```{r echo=FALSE, fig.width=5, fig.height=3} -->
<!-- RESIDENTS[[1]] -->
<!-- d=res[,1]*z+durations -->
<!-- d -->
<!-- ``` -->

<!-- ## Quality of the output plans -->

<!-- *One issue currently is that over a population of agents, activities with longer durations tend to dominate over those with shorter durations as the day goes on.* The issue can be seen below in a comparison between the input activities distributions and the distributions calculated from the produced output plans, for 1000 residents: -->

<!-- ```{r echo=FALSE, fig.width=4, fig.height=3} -->

<!-- R_activities -->
<!-- n_activities = 100*(R_activities)/N -->
<!-- input -->
<!-- plotActivities("Resident activities (Output)", "Percentage", "Time of day", n_activities) -->
<!-- ``` -->


<!-- If we compare this to the expected allocations, we see that late in the day, `home` tends to be down and `work` up from expected:  -->
<!-- ```{r echo=FALSE, fig.width=5, fig.height=3} -->
<!-- #(R_activities/N-r_activities/1000) -->
<!-- diff_activities<-n_activities-r_activities -->
<!-- plotActivities("Resident activities (Output - Input)", "Percentage", "Time of day", diff_activities, limitY=FALSE) -->
<!-- ``` -->


## Activity distributions in original SCS plans file

Here is what the distributions of activity **end times** in the [initial population from Surf Coast Shire Council](https://github.com/agentsoz/bdi-abm-integration/blob/kaibranch/examples/bushfire/scenarios/surf-coast-shire/data/from-scsc-201804/analysis-data-from-scsc-201804.md#surf-coast-shire-trips-scscsvgz) look like, as well as after mapping to our activity classes as follows:

  * `home=Base`
  * `beach=Beach`
  * `education=Kindergarten,Primary,Secondary,Tafe,University`
  * `other=[Camp,Caravan Park,Golf Club,Hotel,EvacZone]`
  * `shops=Shops` 
  * `work=Business District`


```{r echo=FALSE, fig.width=4.2, fig.height=4}

### Resident (derived from SCS initial plans file)
csv <- read.csv(gzfile("../from-scsc-201804/trips-scs.csv.gz"), header=T, sep=",")

isFactor <- sapply(csv, is.factor)
csv[isFactor] <- lapply(csv[isFactor], as.character)
a <- strptime(csv[,"act.end_time"], format="%H:%M:%S")
b<-as.numeric(difftime(a,strptime(0,"%H"), units = "hours"))
csv[,"act.end_time"]<-b
end_times<-csv[,c("act.end_time","type")]
ggplot(end_times, aes(x=act.end_time, fill=type)) + geom_histogram(bins=12) +
  theme(legend.position = "bottom", legend.title=element_text(size=8), legend.text=element_text(size=7), legend.key.size = unit(0.6, "line")) 

# Try to map to our activties
df<-end_times
df$type[df$type=="Base"]<-"home"
df$type[df$type=="Business District"]<-"work"
df$type[df$type=="Beach"]<-"beach"
df$type[df$type=="Shops"]<-"shops"
df$type[df$type=="Kindergarten"]<-"education"
df$type[df$type=="Primary"]<-"education"
df$type[df$type=="Secondary"]<-"education"
df$type[df$type=="Tafe"]<-"education"
df$type[df$type=="University"]<-"education"
df$type[df$type=="Camp"]<-"other"
df$type[df$type=="Caravan Park"]<-"other"
df$type[df$type=="Golf Club"]<-"other"
df$type[df$type=="Hotel"]<-"other"
df$type[df$type=="EvacZone"]<-"other" # ??
ggplot(df, aes(x=act.end_time, fill=type)) + geom_histogram(bins=12) +
  theme(legend.position = "bottom", legend.title=element_text(size=8), legend.text=element_text(size=7), legend.key.size = unit(0.6, "line")) 

show("Number of unique persons")
length(unique(csv$person.id))

```

This is just for information so we can get some sense of what the new inputs requirements are compared to the original.  <mark>Discuss with SCS next steps for constructing the input distributions.</mark>