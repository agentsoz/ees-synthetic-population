---
title: "On creating a synthetic population for Surf Coast Shire for evacuation modelling"
author: Dhirendra Singh
date: 17 April, 2018
output:
  html_document:
    keep_md: yes
#  md_document:
#    variant: markdown_github
---

[Surf Coast Shire](https://www.openstreetmap.org/relation/3290432) is unique in its population makeup on a given summer day, due to the significant high number of tourists in and around the townships that line the [Great Ocean Road](https://www.openstreetmap.org/relation/6592912). For instance, accounts from emergency services personnel suggest that the population of Angleasea can be as high as `15000` persons on a summer day, when the [resident population of Anglesea according to the 2016 census is around `2600`](http://www.censusdata.abs.gov.au/census_services/getproduct/census/2016/quickstat/SSC20045).  In looking to construct a synthetic population for Surf Coast Shire for the purposes of evacuation modelling then, it is importnat that the significantly high volume of traffic from tourism related activities in the area is accounted for. Further, the behaviour of tourists in case of an emergency is likely to differ from local residents, at least as far as knowledge of local roads is concerned.

One way to to approach the problem is to construct the population in *layers* of identified groups of people, that are then superimposed to create a final population on a given day. This gives finer control over modelled scenarios, such as to capture days with "packed" beaches, special events like the Falls Festival, and/or high through-traffic. 

## Evacuee types

Initial discussions with stakeholders (at Anglesea CFA, 16/04/18) identified the following three groups that conceptually make up the population:

* **Residents** : as captured by the [ABS census data](http://www.censusdata.abs.gov.au/census_services/getproduct/census/2016/quickstat/LGA26490); several methods exist for creating a synthetic population for this cohort, and one that could be readily applied here is the [algorithm from Wicramasinghe et al.](https://github.com/agentsoz/synthetic-population) from RMIT University. 
* **Regular visitors** : people that regularly visit the region during the summer months, camping or in *holiday homes*, and have a working knowledge of local roads and destinations; some information on this cohort could be derived from [VISTA data](https://transport.vic.gov.au/data-and-research/vista/). (<mark>Any other dataset that might give stats on this group?</mark>)
* **Tourists** : people that visit the region for the day or on a short-stay visit, and generally do not know the area well; some information on this cohort could be derived from [VISTA data](https://transport.vic.gov.au/data-and-research/vista/). (<mark>Any other dataset that might give stats on this group?</mark>)

These would likely be entered into DSS in the following format:

Type | Total numbers
----- | -----
Resident | 2500 (from ABS)
Regular Visitor | 2000
Tourist | 7000


## Evacuee response to messaging

The following table shows a suggested distribution of responses to various messages, for different types of persons (**each row must add up to 100%**). <mark>For discussion with Surf Coast Shire.</mark>

Person type | Evacuate on `Advice` | Evacuate on `Watch & Act` | Evacuate on `Evacuate Now` | Will not evacuate | Justification 
--------------|---------|---------|---------|---------|--------------------------------------------
Resident | 5% | 15% | 50% | 30% | Least likely to react to initial warnings; most likely to stay back 
Regular Visitor | 10% | 20% | 60% | 10% | More likely to react to warnings; less likely to stay back 
Tourist | 15% | 25% | 60% | 0% | Most likely to react early; least likely to stay back 

## Whereabouts of the population during the day

The current approach for building an understanding of the activities and whereabouts of the population at the time of the first warning is based on combining various sources of information to produce a trip-based activity plan for each person (see [example Surf Coast Shire trips](../from-scsc-201804/analysis-data-from-scsc-201804.html)). The trips can then be played out in MATSim, as a preparatory step, and *snapshots* of the population taken at desired times during the simulated day. These time-of-day based snapshots can then be used as inputs for evacuation scenarios as required.  
The key drawback of this approach is that the preparatory process requires manual manipulation (currently restricted to SCS personnel to produce the trips CSV file) which can be time consuming. This inherently restricts the amount of variation that can be built into the initial population, since each variation requires a separate application of the above process. For instance, it would be difficult to easily construct sets of initial populations that vary only in terms of size and makeup with respect to the identified evacuee groups.

The suggested approach would be to instead specify the initial population and its time-of-day based activities in terms of distributions, that are more amenable to easy manipulation between scenarios. This would remove the manual preprocessing step altogether, since the starting population for any new scenario would be fully described by and built from these distributions alone. For instace, the activity-based behaviours of the population could likely be simplified to being `at home`, `at work`, `at shops`, `at beach`, or `at other location`. These distributions would "look" similar for all types of persons, however the proportion of each type performing those activities would vary. 

Below is an example showing what two such distribution might look like:

```{r echo=FALSE, fig.width=8, fig.height=3}
library(ggplot2)

x<-seq(from=0, to=23,length.out=1000)
y<-dnorm(x, mean=14, sd=2)
y<-y/max(y)
a<-rep("At Beach", length(x))
df1<-data.frame(Hour=x,Proportion=y, Activity=a)

y<-dnorm(x, mean=11, sd=2)
y<-y/max(y)
y2<-dnorm(x, mean=18, sd=3)
y2<-y2/max(y2)
y<-y+y2
y<-y/max(y)
a<-rep("At Shops", length(x))
df2<-data.frame(Hour=x,Proportion=y, Activity=a)

df<-rbind(df1,df2)
ggplot(df,aes(x=Hour,y=Proportion, color=Activity)) +labs(y="Proportion", x="Hour of day") +geom_line()
```

Proportion of the population of each type, likely to perform a given activity during the day (will be applied to the time-of-day distributions above):

Activity | Resident | Regular Visitor | Tourist
----- | ----- | ----- | -----
`At Home` | - | - | -
`At Work` | - | - | - 
`At beach` | 0.3 | 0.7 | 0.9 
`At Shops` | 0.5 | 0.7 | 0.9 
`At Other Location` | - | - | - 

Each activity will in turn be associated with a location, a set of locations, or areas (polygons).

The above information could then be used to automatically construct a "daily plan" for a given person. It may include several of the above activities, based on values specified in the ablve table. The information above is sufficient to determine the wherabouts of the full population at any time during the day.


---

### Scratchpad

*What is below is work in progress so please ignore for now.*

---

```{r message=FALSE, warning=FALSE, include=FALSE}
suppressMessages(require(reshape2))
require(ggplot2)

# Function to plot a matrix of activities, where
# cols represent activities (such that each col adds up to 100%)
# rows represent time of day (hours)
# Assumes 12 entries per row (for each 2 hour interval)
plotActivities <- function (plotTitle, x_lab, y_lab, activities) {
df<-melt(activities)
colnames(df)<-c("Activity", "Hour", "Proportion")
df$Hour<-(df$Hour-0.5)*2 # get the time of day correct
ggplot(df, aes(Hour, Proportion, fill=Activity)) +
  geom_col() +
  ggtitle(plotTitle) + 
  scale_y_continuous(name=x_lab, limits=c(0,100), breaks=seq(0,100,10)) +
  scale_x_continuous(name=y_lab, limits=c(0,24), breaks=seq(2,24,2)) +
  theme(legend.position = "bottom", legend.title=element_text(size=8), legend.text=element_text(size=7), legend.key.size = unit(0.6, "line")) 
}

```

#### Dhi, ver 0.3

The idea described in `v0.2` below works ok algorithmically, but is not user friendly, because specifying the start time distributions manully is not intuitive and is likely to be error-prone. Certainly, the kinds of distributions drawn in `v0.1`, that capture what people are doing at different times of the day, make more sense for users. 

One option is to get users to specify the input in `v0.1`-like along with typical durations of activities, and then derive from those, the distributions required by the algorithm, i.e., `v0.2`-like. Here is an attempt at that.

Say we start with the following input distribution in the `v0.1` style:

```{r echo=FALSE, fig.width=5, fig.height=3}

### Resident

#hour   = c( 2,  4,  6,  8, 10, 12, 14, 16, 18, 20, 22, 24)
r_home  = c(90, 90, 85, 75, 30, 20, 15, 10, 20, 45, 70, 85)
r_work  = c( 5,  5, 10, 15, 50, 60, 60, 50, 50, 40, 20, 10)
r_beach = c( 0,  0,  0,  0,  5,  5, 10, 15,  5,  0,  0,  0)
r_shops = c( 0,  0,  0,  0, 10, 10, 10, 20, 20, 10,  5,  0)
r_other = 100 - (r_home + r_work + r_beach + r_shops)
r_activities = rbind(home=r_home, work=r_work, beach=r_beach, shops=r_shops, other=r_other)
n_activities = 100 * (r_activities / colSums(r_activities))
show(n_activities)
plotActivities("Resident", "Percentage", "Time of day", n_activities)
```

As well as the following typical durations:
```{r echo=FALSE, fig.width=5, fig.height=3}
durations<-matrix(c(12,8,2,1,1), nrow=1, dimnames=list(c("hours"), c("home","work","beach","shops","other")))
show(durations)
```

Now, let's just work with the `work` activity which has a typical duration ``r durations[,"work"]`` and looks like:
```{r echo=FALSE, fig.width=5, fig.height=3}
n_work<-matrix(n_activities["work",], nrow=1, ncol=length(n_activities["work",]), dimnames=list("work"))
show(n_work)
plotActivities("Residents at work (user input)", "Percentage", "Time of day", n_work)
```

```{r echo=FALSE, fig.width=5, fig.height=3}

derive_start_time <- function (n_activity) {
  activity_name<-rownames(n_activity)[1]
  s_activity=matrix(0, nrow = dim(n_activity)[1], ncol = dim(n_activity)[2], dimnames=dimnames(n_activity)) # matrix to store start times
  t_work<-n_activity # temp copy of work matrix
  #print("t_work"); print(t_work)
  typical_duration<-durations[,activity_name]
  block_size<-24/length(n_activity[activity_name,])
  for(h in 1:length(n_activity[activity_name,])) {
    h_work<-t_work[activity_name,h] # find out how many started work this hour
    #cat("h_work", h_work, "\n")
    s_activity[activity_name,h]<-h_work # save the start times for this hour
    #print("s_activity"); print(s_activity)
    block<-typical_duration/block_size # towards future bins to impact 
    block<-min(length(n_activity[activity_name,])-h+1, block) # towards future bins to impact
    bins<-h:(h+block-1) # ids of bins impacted
    #cat("bins impacted:", bins, "\n")
    t_work[activity_name, bins]<-t_work[activity_name, bins]-h_work # remove those who started work this hour
    t_work[t_work<0]<-0 # don't go below zero
    #print("t_work"); print(t_work)
  }
  return(s_activity)
}
```

The idea would be to cycle through the time bins for the day, and for each bin, save the number of persons starting the activity, and then remove those persons from the future bins corresponding to the typical duration of the activity. We then repeat the process for the next time bin. Here is what this looks like for the `work` activity:

```{r echo=FALSE, fig.width=5, fig.height=3}
n_work<-matrix(n_activities["work",], nrow=1, ncol=length(n_activities["work",]), dimnames=list("work"))
s_work<-derive_start_time(n_work)
plotActivities("Residents starting work (derived)", "Percentage", "Time of day", s_work)
show(s_work)
```

Here is the same algorithm now applied to all the activities:

```{r echo=FALSE, fig.width=5, fig.height=3}
s_times<-matrix(0, nrow=nrow(n_activities), ncol=ncol(n_activities), dimnames=dimnames(n_activities))
for(activity in rownames(n_activities)) {
  n_activity<-matrix(n_activities[activity,], nrow=1, ncol=length(n_activities[activity,]), dimnames=list(activity))
  s_activity<-derive_start_time(n_activity)
  s_times[activity,]<-s_activity
}
plotActivities("Residents starting activities (derived)", "Percentage", "Time of day", s_times)
show(s_times)
```


#### Dhi, ver 0.2

Outputs of agent-based simulation models are inherently very sensitive to the input population. For the GOR DSS, defining where the population is, what it is doing, and what it will do in response to an emergency will strongly influence the outputs. 

This is a proposal for *how the population will be specified by users*. The intent is to:

* make all inputs and assumptions about the underlying population explicit so that they can be more easily critiqued, debated, and agreed upon;
* allow differences between populations of different scenarios to be easily understood and described;
* allow users to generate populations for different scenarios easily; and
* formalise the method of producing such populations, so that they can be accurately reproduced.

In particular, what is proposed is a process for the construction of the input population with respect to the *expected spread of activites in the day* for different situations. The *output of the process is a CSV file*, similar to what is currently used as input to the DSS, that describes the daily activity-plan for every individual in the population.

We will make the following assumptions with respect to the activities of the population:

1. The choice of activities will be limited to the following fixed set:

Activity | Description
---------- | -------------------------------------------------------------------
**`home`** | *performed twice a day (morning, night)* at the home location of a person; these locations could either be random locations in the region, or random selections from known street addresses in the region (data available from LandVic); <mark>other suggestions welcome</mark>;
**`work`** | *performed once a day* at locations designated as work areas in the region (<mark>supplied by Surf Coast Shire Council</mark>); persons will be assigned arbitrary work location coordinates in these areas; the proportion of the resident population that forms the working cohort will be based on census data for the region (`ABS 2016: SCS had 90.6% employed of which 66% drive to work`); 
**`shop`** | *performed potentially once a day* at locations that represent retail and grocery shops as well as dining places; <mark>supplied by Surf Coast Shire Council</mark> 
**`beach`** | *performed potentially once a day* at areas designated as beach destinations along the coast (<mark>supplied by Surf Coast Shire Council</mark>); the population will have equal preference for all beaches; 
**`other`** | *performed potentially several times a day* at arbitrary locations other than those above (not including commuting); will be used as needed to make daily plans coherent.

1. Each population subgroup (i.e, `resident`, `regular visitor`, `tourust`) will differ in how they perform the above activities in the following ways:
    1. The proportions in which subgroups perform different activities will be different; for instance tourists might be more likely to go to the beach than residents; another example is that all residents will perform the home activity while none of the tourists will.
    1. The times at which subgroups perform activities will be different: for instance, tourists might be more likely to visit the beach around noon, whereas residents might be more inclined to go to the beach in the mornings and evenings to avoid the rush.
    1. The durations for which each subgroup performs activites will be different: for instance, tourists might spend more time at the beach than residents.

1. Overall, individuals in the full population will differ in the makeup of their daily activity plans with respect to which activities they perform, when, for how long, and in which order.

1. Each activity will be fully described by (1) a distribution specifying the expected start times in the day for the activity and (2) the *typical duration* of the activity (more on this below); these will differ for different situations such as between weekdays and weekends, and also for subgroups, such as between residents and tourists. Each scenario, such as "typical weekday" , will therefore be fully specified by three distributons (one per subgroup) and three activity durations. Each new scenario, such as "weekend", "40 degree day" will require three new distributions (and activity durations) each, so is not expected to be too onerous for users.

  1. The `typical duration` of an activity is the time a person will spend performing that activity under normal conditions, for instance 8hrs for `work`. The actual duration might get squeezed or stretched depending on how things play out during the simulation, such as due to traffic congestion. Details of the precise algorithm for this can be found in the MATSim user guide. 
  
  1. Currently in the model *persons* are synonomous with *vehicles*. In other words, all vehicles accommodate a single person (the driver) and drivers are assumed to be co-located with their vehicles. For SCS, it *might be important to model persons walking to activities from their parked vehicles and back at the end of the activity*. This might be important for the `beach` activity in particular, where the time spent in walking from/to the parked vehicle might be significant; <mark>Discuss with working group</mark>.

The following graphs show what the activity start time distributions and durations might look like for a "typical weekday":

```{r echo=FALSE, fig.width=5, fig.height=3}

### Resident

durations<-data.frame(activity=c("home","work","beach","shops","other"), typical_duration=c(12,8,2,1,1))
#hour   = c(  2,   4,   6,   8,  10,  12,  14,  16,  18,  20,  22,  24)
r_home  = c(100,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0)
r_work  = c(  0,   0,  30,  70,   0,   0,   0,   0,   0,   0,   0,   0)
r_beach = c(  0,   0,   5,  10,   0,   0,   0,   0,  10,   5,   0,   0)
r_shops = c(  0,   0,   0,   5,   5,   5,   5,  10,  20,  20,   5,   0)
r_other = c(  0,   5,  10,  10,   5,  15,  10,  10,  10,  10,   5,   0)
r_activities = rbind(home=r_home, work=r_work, beach=r_beach, shops=r_shops, other=r_other)
n_activities = r_activities #100 * (r_activities / colSums(r_activities))
plotActivities("Resident: activity start times", "Percentage", "Time of day", n_activities)
print("Activity start times (24hrs split over columns)");show(n_activities)
cat("Row sums (can exceed 100 if performed multiple times in the day):", rowSums(n_activities))
cat("Col sums (should not exceed 100):", colSums(n_activities))
show(durations)


### Regular Visitor


### Tourist


```


#### Dhi, v0.1

The plots below show what the distribution of activities might look like for the identified groups *on a typical weekday*.  

```{r echo=FALSE, fig.width=5, fig.height=3}

### Resident

#hour   = c(  2,   4,   6,   8,  10,  12,  14,  16,  18,  20,  22,  24)
r_home  = c(900, 900, 850, 750, 300, 200, 150, 100, 200, 450, 700, 850)
r_work  = c( 50,  50, 100, 150, 500, 600, 600, 500, 500, 400, 200, 100)
r_beach = c(  0,   0,   0,   0,  50, 50,  100, 150,  50,   0,   0,   0)
r_shops = c(  0,   0,   0,   0, 100, 100, 100, 200, 200, 100,  50,   0)
r_other = 1000 - (r_home + r_work + r_beach + r_shops)
r_activities = rbind(home=r_home, work=r_work, beach=r_beach, shops=r_shops, other=r_other)
n_activities = 100 * (r_activities / colSums(r_activities))
show(n_activities)
plotActivities("Resident", "Percentage", "Time of day", n_activities)


### Regular Visitor

#hour   = c(  2,   4,   6,   8,   10,  12,  14,  16,  18,  20,  22,  24)
r_home  = c(900, 950, 950, 850, 800, 650, 300, 250, 300, 400, 600, 700)
r_work  = c(  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0)
r_beach = c(  0,   0,   0,  50, 100, 100, 300, 400, 300, 100,  50,   0)
r_shops = c(  0,   0,   0,   0,  50, 100, 350, 200, 150, 400, 200,   0)
r_other = 1000 - (r_home + r_work + r_beach + r_shops)
r_activities = rbind(home=r_home, work=r_work, beach=r_beach, shops=r_shops, other=r_other)
n_activities = 100 * (r_activities / colSums(r_activities))
show(n_activities)
plotActivities("Regular Visitor", "Percentage", "Time of day", n_activities)

### Tourist

#hour   = c(  2,   4,   6,   8,   10,  12,  14,  16,  18,  20,  22,  24)
r_home  = c(  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0)
r_work  = c(  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0)
r_beach = c(  0,   0,   0,  100, 200, 600, 700, 600, 300, 100,  50,   0)
r_shops = c(  0,   0,   0,  100, 200, 300, 200, 200, 600, 500, 200,   0)
r_other = 1000 - (r_home + r_work + r_beach + r_shops)
r_activities = rbind(home=r_home, work=r_work, beach=r_beach, shops=r_shops, other=r_other)
n_activities = 100 * (r_activities / colSums(r_activities))
show(n_activities)
plotActivities("Tourist", "Percentage", "Time of day", n_activities)

```

```{r echo=FALSE, fig.width=5, fig.height=3}

###Algorithm to generate a resident plan (based on ver 0.1)

#timestep
i=2


### DURATIONS in hours (home,work,beach,shops,other)
durations<-c(i,8,4,4,4)

dur<-(durations/i)
n=24/i
p=n/12
#RESIDENTS
res<-r_activities/1000
res<-1-(1-res)^(1/p)
res<-apply(res,2,cumsum)
res<-replicate(p,res)
res<-lapply(1:ncol(res),function(x)cbind(res[,x,]))
res<-Reduce(cbind,res)

roll<-runif(n)
res<-apply(res,1,function(x){roll<x})
res<-apply(res,1,cumsum)
res[res>1]=0
res<-dur*res
z=rep(0,5)
s=0
for (j in 1:n)
{
 if(s>0)
   {res[,j]=z
   s=s-1}
  else {s=sum(res[,j])-1}
}





```
